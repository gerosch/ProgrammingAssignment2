<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Introduction</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<h3>Introduction</h3>

<p>This document contains the results from a quick unit test of this assignment.
To easily create a (nxn)-matrix the additional package &#39;magic&#39; has been used in this unit test. The command <code>magic(n)</code> creates an invertible (nxn)-matrix. </p>

<h3>Unit Test Results</h3>

<p>In this part the results from the unit test of the functions <code>makeCacheMatrix()</code> and <code>cacheSolve()</code> are provided.</p>

<!-- -->

<p>Sourcing the code from the assignment we create a 5x5 matrix A using <code>magic(5)</code>: </p>

<pre><code>  &gt; source(&quot;../ProgrammingAssignment2/cachematrix.R&quot;)

  &gt; library(magic)
  Loading required package: abind

  &gt; A&lt;-magic(5) ##  helps to easily create squared invertible matrices

  &gt; A
       [,1] [,2] [,3] [,4] [,5]
  [1,]    9    2   25   18   11
  [2,]    3   21   19   12   10
  [3,]   22   20   13    6    4
  [4,]   16   14    7    5   23
  [5,]   15    8    1   24   17
</code></pre>

<p>We then create matrix B as a <code>makeCacheMatrix()</code> object from matrix A:</p>

<pre><code>  &gt; B&lt;-makeCacheMatrix(A)
</code></pre>

<p>We check that the matrix is properly stored in the object B using the <code>getmat()</code> function and verify that the inverse is undefined (NULL) as it has not yet been calculated:</p>

<pre><code>  &gt; B$getmat()
       [,1] [,2] [,3] [,4] [,5]
  [1,]    9    2   25   18   11
  [2,]    3   21   19   12   10
  [3,]   22   20   13    6    4
  [4,]   16   14    7    5   23
  [5,]   15    8    1   24   17

  &gt; B$getinv() 
  NULL
</code></pre>

<p>We then use <code>cacheSolve</code> to calculate the inverse of matrix A in object B and see that the inverse is newly calculated when the function is invoked for the first time:</p>

<pre><code>  &gt; cacheSolve(B)
  newly calculating data
               [,1]         [,2]         [,3]         [,4]         [,5]
  [1,]  0.011089744 -0.045000000  0.041538462  0.005000000  0.002756410
  [2,] -0.036987179  0.043461538  0.010769231 -0.006538462  0.004679487
  [3,]  0.036410256  0.003076923  0.003076923  0.003076923 -0.030256410
  [4,]  0.001474359  0.012692308 -0.004615385 -0.037307692  0.043141026
  [5,]  0.003397436  0.001153846 -0.035384615  0.051153846 -0.004935897
</code></pre>

<p>When invoking the <code>cacheSolve()</code> function for the second time the inverse is taken from the cached data which is stored in the object B:</p>

<pre><code>  &gt; cacheSolve(B)
  getting cached data
               [,1]         [,2]         [,3]         [,4]         [,5]
  [1,]  0.011089744 -0.045000000  0.041538462  0.005000000  0.002756410
  [2,] -0.036987179  0.043461538  0.010769231 -0.006538462  0.004679487
  [3,]  0.036410256  0.003076923  0.003076923  0.003076923 -0.030256410
  [4,]  0.001474359  0.012692308 -0.004615385 -0.037307692  0.043141026
  [5,]  0.003397436  0.001153846 -0.035384615  0.051153846 -0.004935897
</code></pre>

<p>We verify that the inverse is properly stored in the matrix object B:</p>

<pre><code>  &gt; B$getinv()
               [,1]         [,2]         [,3]         [,4]         [,5]
  [1,]  0.011089744 -0.045000000  0.041538462  0.005000000  0.002756410
  [2,] -0.036987179  0.043461538  0.010769231 -0.006538462  0.004679487
  [3,]  0.036410256  0.003076923  0.003076923  0.003076923 -0.030256410
  [4,]  0.001474359  0.012692308 -0.004615385 -0.037307692  0.043141026
  [5,]  0.003397436  0.001153846 -0.035384615  0.051153846 -0.004935897
</code></pre>

<p>When we use the <code>setmat()</code> function of the object B to change the matrix in the object the inverse is cleared and set to NULL (undefined)</p>

<pre><code>  &gt; B$setmat(A)

  &gt; B$getinv()
  NULL
</code></pre>

<p>A new call of <code>cacheSolve(B)</code> will now correctly trigger a new calculation of the inverse (as the matrix in the object has changed):</p>

<pre><code>  &gt; cacheSolve(B)
  newly calculating data
               [,1]         [,2]         [,3]         [,4]         [,5]
  [1,]  0.011089744 -0.045000000  0.041538462  0.005000000  0.002756410
  [2,] -0.036987179  0.043461538  0.010769231 -0.006538462  0.004679487
  [3,]  0.036410256  0.003076923  0.003076923  0.003076923 -0.030256410
  [4,]  0.001474359  0.012692308 -0.004615385 -0.037307692  0.043141026
  [5,]  0.003397436  0.001153846 -0.035384615  0.051153846 -0.004935897
</code></pre>

<p>The second call of <code>cacheSolve(B)</code> will then retrieve the (already calculated) inverse from cache (i.e. from the data stored in the object):</p>

<pre><code>  &gt; cacheSolve(B)
  getting cached data
               [,1]         [,2]         [,3]         [,4]         [,5]
  [1,]  0.011089744 -0.045000000  0.041538462  0.005000000  0.002756410
  [2,] -0.036987179  0.043461538  0.010769231 -0.006538462  0.004679487
  [3,]  0.036410256  0.003076923  0.003076923  0.003076923 -0.030256410
  [4,]  0.001474359  0.012692308 -0.004615385 -0.037307692  0.043141026
  [5,]  0.003397436  0.001153846 -0.035384615  0.051153846 -0.004935897
</code></pre>

<h4>Test using the inverse as the initial matrix</h4>

<p>When setting the inverse matrix as the initial matrix in object B with the <code>setmat()</code> function then the result of <code>cacheSolve()</code> should return the original matrix A from the beginning as inverse (of the inverse):</p>

<pre><code>  &gt; C&lt;-cacheSolve(B)
  getting cached data

  &gt; B$setmat(C) ## set inverse as initial matrix 

  &gt; B$getinv()  ## matrix has changed / inverse is set to NULL
  NULL

  &gt; cacheSolve(B) ## 1st call triggers new calculation
  newly calculating data
       [,1] [,2] [,3] [,4] [,5]
  [1,]    9    2   25   18   11
  [2,]    3   21   19   12   10
  [3,]   22   20   13    6    4
  [4,]   16   14    7    5   23
  [5,]   15    8    1   24   17

  &gt; cacheSolve(B) ## 2nd call retrieves the cached data from object
  getting cached data
       [,1] [,2] [,3] [,4] [,5]
  [1,]    9    2   25   18   11
  [2,]    3   21   19   12   10
  [3,]   22   20   13    6    4
  [4,]   16   14    7    5   23
  [5,]   15    8    1   24   17

  ## inverse of the inverse gives the original matrix A
</code></pre>

<h4>Failure test with non-invertible matrix</h4>

<p>When using a non-invertible matrix for A then the <code>cacheSolve)()</code> function fails in the same way as the basic <code>solve()</code> function does:</p>

<pre><code>  &gt; a=1:5
  &gt; b=3:7
  &gt; c=7:11
  &gt; d=2:6
  &gt; e=5:9

  &gt; A=cbind(a,b,c,d,e)

  &gt; A
       a b  c d e
  [1,] 1 3  7 2 5
  [2,] 2 4  8 3 6
  [3,] 3 5  9 4 7
  [4,] 4 6 10 5 8
  [5,] 5 7 11 6 9

  &gt; B=makeCacheMatrix(A)

  &gt; cacheSolve(B)
  newly calculating data
   Show Traceback

   Rerun with Debug
   Error in solve.default(matrix, ...) : 
    Lapack routine dgesv: system is exactly singular: U[5,5] = 0 

  &gt; solve(A)
  Error in solve.default(A) : 
    Lapack routine dgesv: system is exactly singular: U[5,5] = 0
</code></pre>

</body>

</html>

